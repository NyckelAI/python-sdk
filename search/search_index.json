{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nyckel Python SDK","text":"<p>Nyckel is a Custom Classification API. It allows you to train, deploy and invoke custom text, image and tabular classification functions.</p> <pre><code>from nyckel import Credentials, TextClassificationFunction\n\ncred = Credentials(client_id=\"...\", client_secret=\"...\")\n\nfunc = TextClassificationFunction.create(\"IsToxic\", cred)\nfunc.create_samples([\n    (\"This is a nice comment\", \"Not toxic\"),\n    (\"Hello friend\", \"Not toxic\"),\n    (\"I hate people like you\", \"Toxic\"),\n    (\"Who is this? Go away!\", \"Toxic\"),\n])\n\npredictions = func.invoke([\"This example is fantastic!\"])\n</code></pre>"},{"location":"#get-started","title":"Get started","text":"<ul> <li>Visit Nyckel and sign up for a free account</li> <li>Install the SDK: <code>pip install nyckel</code></li> <li>Explore the SDK for text, image and tabular classification</li> </ul>"},{"location":"classify/","title":"Classify","text":"<p>This is a low-level function that allows you to invoke your function with custom data. It currently only supports Classification function types.</p>"},{"location":"classify/#nyckel.invoke","title":"nyckel.invoke","text":"<pre><code>invoke(function_id: str, data: str, credentials: Credentials) -&gt; Dict\n</code></pre> Source code in <code>src/nyckel/functions/pretrained.py</code> <pre><code>def invoke(function_id: str, data: str, credentials: Credentials) -&gt; Dict:\n    session = credentials.get_session()\n    endpoint = f\"https://www.nyckel.com/v1/functions/{function_id}/invoke\"\n    return session.post(endpoint, json={\"data\": data}).json()\n</code></pre>"},{"location":"copy_function/","title":"Copy Function","text":"<p>Use the Nyckel SDK to quickly copy your Nyckel function to a new function.</p> <pre><code>from nyckel import Credentials, TextClassificationFunction\n\n# Get credentials from https://www.nyckel.com/console/keys\ncredentials = Credentials(client_id=..., client_secret=...)\n\n# Load the source function.\nfrom_func = TextClassificationFunction(\"&lt;function_id&gt;\", credentials)\n\n# Create a new, empty function.\nto_func = TextClassificationFunction.create(f\"{from_func.name} COPY\", credentials)\n\n# Copy samples over. Labels will automatically be created.\nto_func.create_samples(from_func.list_samples())\n</code></pre>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#nyckel.Credentials","title":"nyckel.Credentials","text":"<p>API credentials for Nyckel. Handles renewal of OAuth2 bearer token.</p> <p>Example:</p> <pre><code>credentials = Credentials(client_id=\"...\", client_secret=\"...\")\nsession = credentials.get_session()\nmy_functions = session.get(\"https://www.nyckel.com/v1/functions\")\n</code></pre> Source code in <code>src/nyckel/auth.py</code> <pre><code>class Credentials:\n    \"\"\"API credentials for Nyckel. Handles renewal of OAuth2 bearer token.\n\n    Example:\n\n        credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n        session = credentials.get_session()\n        my_functions = session.get(\"https://www.nyckel.com/v1/functions\")\n\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str, server_url: str = \"https://www.nyckel.com\"):\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._server_url = server_url.rstrip(\"/\")\n        self._renew_at = 0\n        self._bearer_token: str = \"\"\n\n    @property\n    def token(self) -&gt; str:\n        if time.time() &gt; self._renew_at:\n            self._renew_token()\n        return self._bearer_token\n\n    @property\n    def server_url(self) -&gt; str:\n        return self._server_url\n\n    @property\n    def client_id(self) -&gt; str:\n        return self._client_id\n\n    def get_session(self) -&gt; requests.Session:\n        \"\"\"Returns a requests session with active bearer token header.\"\"\"\n        session = get_session_that_retries()\n        try:\n            nyckel_pip_version = version(\"nyckel\")\n        except PackageNotFoundError:\n            nyckel_pip_version = \"dev\"\n\n        session.headers.update(\n            {\n                \"Authorization\": f\"Bearer {self.token}\",\n                \"Nyckel-Client-Name\": \"python-sdk\",\n                \"Nyckel-Client-Version\": nyckel_pip_version,\n            }\n        )\n        return session\n\n    def _renew_token(self) -&gt; None:\n        RENEW_MARGIN_SECONDS = 10 * 60\n\n        token_url = f\"{self._server_url}/connect/token\"\n        data = {\n            \"client_id\": self._client_id,\n            \"client_secret\": self._client_secret,\n            \"grant_type\": \"client_credentials\",\n        }\n\n        response = requests.post(token_url, data=data)\n        if not response.status_code == 200:\n            raise ValueError(f\"{response.status_code=} Failed to renew credentials at {token_url=} using {data=}.\")\n\n        self._bearer_token = response.json()[\"access_token\"]\n        self._renew_at = time.time() + response.json()[\"expires_in\"] - RENEW_MARGIN_SECONDS\n</code></pre>"},{"location":"credentials/#nyckel.Credentials.token","title":"token  <code>property</code>","text":"<pre><code>token: str\n</code></pre>"},{"location":"credentials/#nyckel.Credentials.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre>"},{"location":"credentials/#nyckel.Credentials.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: str\n</code></pre>"},{"location":"credentials/#nyckel.Credentials.__init__","title":"__init__","text":"<pre><code>__init__(client_id: str, client_secret: str, server_url: str = 'https://www.nyckel.com')\n</code></pre> Source code in <code>src/nyckel/auth.py</code> <pre><code>def __init__(self, client_id: str, client_secret: str, server_url: str = \"https://www.nyckel.com\"):\n    self._client_id = client_id\n    self._client_secret = client_secret\n    self._server_url = server_url.rstrip(\"/\")\n    self._renew_at = 0\n    self._bearer_token: str = \"\"\n</code></pre>"},{"location":"credentials/#nyckel.Credentials.get_session","title":"get_session","text":"<pre><code>get_session() -&gt; Session\n</code></pre> <p>Returns a requests session with active bearer token header.</p> Source code in <code>src/nyckel/auth.py</code> <pre><code>def get_session(self) -&gt; requests.Session:\n    \"\"\"Returns a requests session with active bearer token header.\"\"\"\n    session = get_session_that_retries()\n    try:\n        nyckel_pip_version = version(\"nyckel\")\n    except PackageNotFoundError:\n        nyckel_pip_version = \"dev\"\n\n    session.headers.update(\n        {\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Nyckel-Client-Name\": \"python-sdk\",\n            \"Nyckel-Client-Version\": nyckel_pip_version,\n        }\n    )\n    return session\n</code></pre>"},{"location":"data_classes/","title":"Data classes","text":""},{"location":"data_classes/#nyckel.NyckelId","title":"nyckel.NyckelId  <code>module-attribute</code>","text":"<pre><code>NyckelId = str\n</code></pre> <p>Unique 16 char alphanumerical string. For example: <code>9ab6nqe7dh5u2ppf</code></p>"},{"location":"data_classes/#nyckel.LabelName","title":"nyckel.LabelName  <code>module-attribute</code>","text":"<pre><code>LabelName = str\n</code></pre>"},{"location":"data_classes/#nyckel.ImageSampleData","title":"nyckel.ImageSampleData  <code>module-attribute</code>","text":"<pre><code>ImageSampleData = str\n</code></pre> <p>DataUri, Url, or local filepath.</p>"},{"location":"data_classes/#nyckel.TextSampleData","title":"nyckel.TextSampleData  <code>module-attribute</code>","text":"<pre><code>TextSampleData = str\n</code></pre>"},{"location":"data_classes/#nyckel.TabularSampleData","title":"nyckel.TabularSampleData  <code>module-attribute</code>","text":"<pre><code>TabularSampleData = Dict[TabularFieldKey, TabularFieldValue]\n</code></pre>"},{"location":"data_classes/#nyckel.TabularFieldKey","title":"nyckel.TabularFieldKey  <code>module-attribute</code>","text":"<pre><code>TabularFieldKey = str\n</code></pre>"},{"location":"data_classes/#nyckel.TabularFieldValue","title":"nyckel.TabularFieldValue  <code>module-attribute</code>","text":"<pre><code>TabularFieldValue = Union[str, float]\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel","title":"nyckel.ClassificationLabel  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass ClassificationLabel:\n    name: LabelName\n    id: Optional[NyckelId] = None\n    description: Optional[str] = None\n    metadata: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: LabelName\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationLabel.__init__","title":"__init__","text":"<pre><code>__init__(name: LabelName, id: Optional[NyckelId] = None, description: Optional[str] = None, metadata: Optional[Dict[str, str]] = None) -&gt; None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPrediction","title":"nyckel.ClassificationPrediction  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass ClassificationPrediction:\n    label_name: LabelName\n    confidence: float\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPrediction.label_name","title":"label_name  <code>instance-attribute</code>","text":"<pre><code>label_name: LabelName\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPrediction.confidence","title":"confidence  <code>instance-attribute</code>","text":"<pre><code>confidence: float\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPrediction.__init__","title":"__init__","text":"<pre><code>__init__(label_name: LabelName, confidence: float) -&gt; None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPredictionError","title":"nyckel.ClassificationPredictionError  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass ClassificationPredictionError:\n    error: str  # Any content / information from the server\n    status_code: int  # HTTP status code\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPredictionError.error","title":"error  <code>instance-attribute</code>","text":"<pre><code>error: str\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPredictionError.status_code","title":"status_code  <code>instance-attribute</code>","text":"<pre><code>status_code: int\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPredictionError.__init__","title":"__init__","text":"<pre><code>__init__(error: str, status_code: int) -&gt; None\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationPredictionOrError","title":"nyckel.ClassificationPredictionOrError  <code>module-attribute</code>","text":"<pre><code>ClassificationPredictionOrError = Union[ClassificationPrediction, ClassificationPredictionError]\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationAnnotation","title":"nyckel.ClassificationAnnotation  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass ClassificationAnnotation:\n    label_name: str\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationAnnotation.label_name","title":"label_name  <code>instance-attribute</code>","text":"<pre><code>label_name: str\n</code></pre>"},{"location":"data_classes/#nyckel.ClassificationAnnotation.__init__","title":"__init__","text":"<pre><code>__init__(label_name: str) -&gt; None\n</code></pre>"},{"location":"data_classes/#nyckel.TagsAnnotation","title":"nyckel.TagsAnnotation  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/tags/tags.py</code> <pre><code>@dataclass\nclass TagsAnnotation:\n    label_name: str\n    present: bool = True\n</code></pre>"},{"location":"data_classes/#nyckel.TagsAnnotation.label_name","title":"label_name  <code>instance-attribute</code>","text":"<pre><code>label_name: str\n</code></pre>"},{"location":"data_classes/#nyckel.TagsAnnotation.present","title":"present  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>present: bool = True\n</code></pre>"},{"location":"data_classes/#nyckel.TagsAnnotation.__init__","title":"__init__","text":"<pre><code>__init__(label_name: str, present: bool = True) -&gt; None\n</code></pre>"},{"location":"data_classes/#nyckel.TagsPrediction","title":"nyckel.TagsPrediction  <code>module-attribute</code>","text":"<pre><code>TagsPrediction = Sequence[ClassificationPredictionOrError]\n</code></pre>"},{"location":"delete_label/","title":"Delete label with samples","text":"<p>Deleting a label is easy in the Nyckel UI, API or indeed this SDK. However, this leaves all samples in the function, but they are no longer associated with a label.</p> <p>This guide shows how to delete a single label along with all samples associated with it.</p> <pre><code>from nyckel import Credentials, TextClassificationFunction\n\n# This is the label name to be deleted\nlabel_name = \"\" \n\n# Initialize your credentials and function\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\nfunc = TextClassificationFunction(\"&lt;function_id&gt;\", credentials)\n\n# Get all samples\nsamples = func.list_samples()\n\n# Filter out the sample associated with the relevant label\nsamples = [sample for sample in samples if sample.annotation]\nsamples = [sample for sample in samples if sample.annotation.label_name == label_to_delete]\n\n# Delete the samples\nfunc.delete_samples([sample.id for sample in samples])\n\n# Delete the label.\nlabel_id_by_name = {label.name: label.id for label in func.list_labels()}\nfunc.delete_labels([label_id_by_name[label_name]])\n</code></pre>"},{"location":"delete_samples/","title":"Delete the most recent samples","text":"<p>Uploaded a bunch of samples by mistake? No problem, you can delete them all at once.</p> <pre><code>from nyckel import Credentials, ImageClassificationFunction\n\n# Load up  your function\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\nfunc = ImageClassificationFunction(\"&lt;function_id&gt;\", credentials)\n\n# Pull out the 500 more recent sample ids\nsamples = func.list_samples()\nsample_ids = [sample.id for sample in samples][:500]\n\n# Delete the samples\nfunc.delete_samples(sample_ids)\n</code></pre>"},{"location":"image_classification/","title":"Image Classification","text":""},{"location":"image_classification/#nyckel.ImageClassificationFunction","title":"nyckel.ImageClassificationFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, ImageClassificationFunction\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = ImageClassificationFunction.create(\"IsCatOrDog\", credentials)\n\n# (or load existing function)\n# func = ImageClassificationFunction(\"function_id\", credentials)\n\n# Create samples\nfunc.create_samples([\n    (\"cat1.jpg\", \"cat\"),\n    (\"cat2.jpg\", \"cat\"),\n    (\"dog1.jpg\", \"dog\"),\n    (\"dog2.jpg\", \"dog\")\n])\n\npredictions = func.invoke([\"cat_or_dog.jpg\"])\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>class ImageClassificationFunction(ClassificationFunction):\n    \"\"\"\n    Example:\n\n    ```py\n    from nyckel import Credentials, ImageClassificationFunction\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = ImageClassificationFunction.create(\"IsCatOrDog\", credentials)\n\n    # (or load existing function)\n    # func = ImageClassificationFunction(\"function_id\", credentials)\n\n    # Create samples\n    func.create_samples([\n        (\"cat1.jpg\", \"cat\"),\n        (\"cat2.jpg\", \"cat\"),\n        (\"dog1.jpg\", \"dog\"),\n        (\"dog2.jpg\", \"dog\")\n    ])\n\n    predictions = func.invoke([\"cat_or_dog.jpg\"])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: str, credentials: Credentials) -&gt; None:\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n        self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n        self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n        self._encoder = ImageEncoder()\n        assert self._function_handler.get_input_modality() == \"Image\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def __repr__(self) -&gt; str:\n        status_string = f\"Name: {self.name}, id: {self.function_id}, url: {self._url_handler.train_page}\"\n        return status_string\n\n    @property\n    def function_id(self) -&gt; NyckelId:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"ImageClassificationFunction\":\n        return factory.ClassificationFunctionFactory.create(name, \"Image\", credentials)  # type: ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(  # type: ignore\n        self, sample_data_list: List[ImageSampleData], model_id: str = \"\"\n    ) -&gt; List[ClassificationPredictionOrError]:\n        return self._sample_handler.invoke(sample_data_list, ImageSampleBodyTransformer(), model_id=model_id)\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        return self._label_handler.delete_labels(label_ids)\n\n    def create_samples(  # type: ignore\n        self,\n        samples: Sequence[  # type: ignore\n            Union[\n                ImageClassificationSample,\n                Tuple[Image.Image, LabelName],\n                Image.Image,\n                Tuple[ImageSampleData, LabelName],\n                ImageSampleData,\n            ]\n        ],\n    ) -&gt; List[NyckelId]:\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n\n        return self._sample_handler.create_samples(typed_samples, ImageSampleBodyTransformer())\n\n    def list_samples(self) -&gt; List[ImageClassificationSample]:  # type: ignore\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n\n        label_name_by_id = {label.id: label.name for label in labels}\n\n        return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]\n\n    def read_sample(self, sample_id: NyckelId) -&gt; ImageClassificationSample:\n        sample_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {label.id: label.name for label in labels}\n\n        return self._sample_from_dict(sample_dict, label_name_by_id)\n\n    def update_annotation(self, sample: ImageClassificationSample) -&gt; None:  # type: ignore\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n\n    def _sample_from_dict(self, sample_dict: Dict, label_name_by_id: Dict) -&gt; ImageClassificationSample:\n        if \"annotation\" in sample_dict:\n            annotation = ClassificationAnnotation(\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"annotation\"][\"labelId\"])],\n            )\n        else:\n            annotation = None\n        if \"prediction\" in sample_dict:\n            prediction = ClassificationPrediction(\n                confidence=sample_dict[\"prediction\"][\"confidence\"],\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"prediction\"][\"labelId\"])],\n            )\n        else:\n            prediction = None\n        if \"sampleSets\" in sample_dict:\n            sample_sets = []\n            for sample_set_dict in sample_dict[\"sampleSets\"]:\n                sample_sets.append(ClassificationSampleSet(id=strip_nyckel_prefix(sample_set_dict[\"sampleSetId\"])))\n        else:\n            sample_sets = None\n        return ImageClassificationSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=sample_dict[\"data\"],\n            external_id=sample_dict[\"externalId\"] if \"externalId\" in sample_dict else None,\n            annotation=annotation,\n            prediction=prediction,\n            sample_sets=sample_sets,\n        )\n\n    def _wrangle_post_samples_input(\n        self,\n        samples: Sequence[\n            Union[\n                ImageSampleData,\n                Image.Image,\n                ImageClassificationSample,\n                Tuple[ImageSampleData, LabelName],\n                Tuple[Image.Image, LabelName],\n            ]\n        ],\n    ) -&gt; List[ImageClassificationSample]:\n        typed_samples: List[ImageClassificationSample] = []\n        for sample in samples:\n            if isinstance(sample, str):\n                typed_samples.append(ImageClassificationSample(data=sample))\n            elif isinstance(sample, Image.Image):\n                typed_samples.append(ImageClassificationSample(data=self._encoder.to_base64(sample)))\n            elif isinstance(sample, (tuple, list)) and isinstance(sample[0], str):\n                image_str, label_name = sample\n                typed_samples.append(\n                    ImageClassificationSample(\n                        data=image_str, annotation=ClassificationAnnotation(label_name=label_name)\n                    )\n                )\n            elif isinstance(sample, (tuple, list)) and isinstance(sample[0], Image.Image):\n                image_pil, label_name = sample\n                typed_samples.append(\n                    ImageClassificationSample(\n                        data=self._encoder.to_base64(image_pil),\n                        annotation=ClassificationAnnotation(label_name=label_name),\n                    )\n                )\n            elif isinstance(sample, ImageClassificationSample):\n                typed_samples.append(sample)\n            else:\n                raise ValueError(f\"Unknown sample type: {type(sample)}\")\n        return typed_samples\n\n    def _create_labels_as_needed(self, samples: List[ImageClassificationSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names = {sample.annotation.label_name for sample in samples if sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def _strip_label_names(self, samples: List[ImageClassificationSample]) -&gt; List[ImageClassificationSample]:\n        for sample in samples:\n            if sample.annotation:\n                sample.annotation.label_name = sample.annotation.label_name.strip()\n        return samples\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: NyckelId\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: str, credentials: Credentials) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def __init__(self, function_id: str, credentials: Credentials) -&gt; None:\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n    self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n    self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n    self._encoder = ImageEncoder()\n    assert self._function_handler.get_input_modality() == \"Image\"\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; ImageClassificationFunction\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"ImageClassificationFunction\":\n    return factory.ClassificationFunctionFactory.create(name, \"Image\", credentials)  # type: ignore\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[ImageSampleData], model_id: str = '') -&gt; List[ClassificationPredictionOrError]\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def invoke(  # type: ignore\n    self, sample_data_list: List[ImageSampleData], model_id: str = \"\"\n) -&gt; List[ClassificationPredictionOrError]:\n    return self._sample_handler.invoke(sample_data_list, ImageSampleBodyTransformer(), model_id=model_id)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    return self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[ImageClassificationSample, Tuple[Image, LabelName], Image, Tuple[ImageSampleData, LabelName], ImageSampleData]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def create_samples(  # type: ignore\n    self,\n    samples: Sequence[  # type: ignore\n        Union[\n            ImageClassificationSample,\n            Tuple[Image.Image, LabelName],\n            Image.Image,\n            Tuple[ImageSampleData, LabelName],\n            ImageSampleData,\n        ]\n    ],\n) -&gt; List[NyckelId]:\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n\n    return self._sample_handler.create_samples(typed_samples, ImageSampleBodyTransformer())\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[ImageClassificationSample]\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def list_samples(self) -&gt; List[ImageClassificationSample]:  # type: ignore\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n\n    label_name_by_id = {label.id: label.name for label in labels}\n\n    return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; ImageClassificationSample\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; ImageClassificationSample:\n    sample_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {label.id: label.name for label in labels}\n\n    return self._sample_from_dict(sample_dict, label_name_by_id)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: ImageClassificationSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def update_annotation(self, sample: ImageClassificationSample) -&gt; None:  # type: ignore\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/image_classification.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample","title":"nyckel.ImageClassificationSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass ImageClassificationSample:\n    data: ImageSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[ClassificationAnnotation] = None\n    prediction: Optional[ClassificationPrediction] = None\n    sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: ImageSampleData\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[ClassificationAnnotation] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[ClassificationPrediction] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.sample_sets","title":"sample_sets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageClassificationSample.__init__","title":"__init__","text":"<pre><code>__init__(data: ImageSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[ClassificationAnnotation] = None, prediction: Optional[ClassificationPrediction] = None, sample_sets: Optional[List[ClassificationSampleSet]] = None) -&gt; None\n</code></pre>"},{"location":"image_classification/#nyckel.ImageSampleData","title":"nyckel.ImageSampleData  <code>module-attribute</code>","text":"<pre><code>ImageSampleData = str\n</code></pre> <p>DataUri, Url, or local filepath.</p>"},{"location":"image_tags/","title":"Image Tags","text":""},{"location":"image_tags/#nyckel.ImageTagsFunction","title":"nyckel.ImageTagsFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, ImageTagsFunction, ImageTagsSample, TagsAnnotation\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = ImageTagsFunction.create(\"ClothingColor\", credentials)\n\n# (or load existing function)\n# func = ImageTagsFunction(\"function_id\", credentials)\n\nfunc.create_samples([\n    ImageTagsSample(data=\"t-shirt1.jpg\", annotation=[TagsAnnotation(\"White\"), TagsAnnotation(\"Blue\")]),\n    ImageTagsSample(data=\"t=shirt2.jpg\", annotation=[TagsAnnotation(\"Red\"), TagsAnnotation(\"White\")]),\n    ImageTagsSample(data=\"jacket.jpg\", annotation=[TagsAnnotation(\"Black\")]),\n    ImageTagsSample(data=\"jeans.jpg\", annotation=[TagsAnnotation(\"Blue\")]),\n])\n\npredictions = func.invoke([\"new-jacket.jpg\"])\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>class ImageTagsFunction(ImageTagsFunctionInterface):\n    \"\"\"\n    Example:\n\n    ```py\n    from nyckel import Credentials, ImageTagsFunction, ImageTagsSample, TagsAnnotation\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = ImageTagsFunction.create(\"ClothingColor\", credentials)\n\n    # (or load existing function)\n    # func = ImageTagsFunction(\"function_id\", credentials)\n\n    func.create_samples([\n        ImageTagsSample(data=\"t-shirt1.jpg\", annotation=[TagsAnnotation(\"White\"), TagsAnnotation(\"Blue\")]),\n        ImageTagsSample(data=\"t=shirt2.jpg\", annotation=[TagsAnnotation(\"Red\"), TagsAnnotation(\"White\")]),\n        ImageTagsSample(data=\"jacket.jpg\", annotation=[TagsAnnotation(\"Black\")]),\n        ImageTagsSample(data=\"jeans.jpg\", annotation=[TagsAnnotation(\"Blue\")]),\n    ])\n\n    predictions = func.invoke([\"new-jacket.jpg\"])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: NyckelId, credentials: Credentials):\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n\n        self._function_handler = TagsFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n        self._sample_handler = TagsSampleHandler(function_id, credentials)\n        self._encoder = ImageEncoder()\n\n        assert self._function_handler.get_input_modality() == \"Image\"\n\n    @property\n    def function_id(self) -&gt; NyckelId:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"ImageTagsFunction\":\n        return tags_function_factory.TagsFunctionFactory().create(name, \"Image\", credentials)  # type:ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(self, sample_data_list: List[ImageSampleData]) -&gt; List[TagsPrediction]:\n        return self._sample_handler.invoke(sample_data_list, ImageSampleBodyTransformer())  # type: ignore\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:  # type:ignore\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label)  # type:ignore\n            for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        return self._label_handler.delete_labels(label_ids)\n\n    def create_samples(self, samples: Sequence[Union[ImageTagsSample, ImageSampleData, Image.Image]]) -&gt; List[NyckelId]:\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n        return self._sample_handler.create_samples(typed_samples, ImageSampleBodyTransformer())\n\n    def _wrangle_post_samples_input(\n        self, samples: Sequence[Union[ImageTagsSample, ImageSampleData]]\n    ) -&gt; List[ImageTagsSample]:\n        typed_samples: List[ImageTagsSample] = []\n        for sample in samples:\n            if isinstance(sample, str):\n                typed_samples.append(ImageTagsSample(data=sample))\n            elif isinstance(sample, Image.Image):\n                typed_samples.append(ImageTagsSample(data=self._encoder.to_base64(sample)))\n            elif isinstance(sample, ImageTagsSample):\n                typed_samples.append(sample)\n            else:\n                raise ValueError(f\"Unknown sample type: {type(sample)}\")\n        return typed_samples\n\n    def _strip_label_names(self, samples: List[ImageTagsSample]) -&gt; List[ImageTagsSample]:\n        for sample in samples:\n            if sample.annotation:\n                for entry in sample.annotation:\n                    entry.label_name = entry.label_name.strip()\n        return samples\n\n    def _create_labels_as_needed(self, samples: List[ImageTagsSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names: set = set()\n        for sample in samples:\n            if sample.annotation:\n                new_label_names |= {annotation.label_name for annotation in sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def list_samples(self) -&gt; List[ImageTagsSample]:\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {label.id: label.name for label in labels}\n\n        return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n\n    def _sample_from_dict(self, sample_dict: Dict, label_name_by_id: Dict) -&gt; ImageTagsSample:\n        if \"annotation\" in sample_dict:\n            annotation = [\n                TagsAnnotation(\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                    present=entry[\"present\"],\n                )\n                for entry in sample_dict[\"annotation\"]\n            ]\n        else:\n            annotation = None\n\n        if \"prediction\" in sample_dict:\n            prediction = [\n                ClassificationPrediction(\n                    confidence=entry[\"confidence\"],\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                )\n                for entry in sample_dict[\"prediction\"]\n            ]\n        else:\n            prediction = None\n\n        return ImageTagsSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=sample_dict[\"data\"],\n            external_id=sample_dict[\"externalId\"] if \"externalId\" in sample_dict else None,\n            annotation=annotation,\n            prediction=prediction,\n        )\n\n    def read_sample(self, sample_id: NyckelId) -&gt; ImageTagsSample:\n        sample_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n        return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n\n    def update_annotation(self, sample: ImageTagsSample) -&gt; None:\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: NyckelId\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: NyckelId, credentials: Credentials)\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def __init__(self, function_id: NyckelId, credentials: Credentials):\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n\n    self._function_handler = TagsFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n    self._sample_handler = TagsSampleHandler(function_id, credentials)\n    self._encoder = ImageEncoder()\n\n    assert self._function_handler.get_input_modality() == \"Image\"\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; ImageTagsFunction\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"ImageTagsFunction\":\n    return tags_function_factory.TagsFunctionFactory().create(name, \"Image\", credentials)  # type:ignore\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[ImageSampleData]) -&gt; List[TagsPrediction]\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def invoke(self, sample_data_list: List[ImageSampleData]) -&gt; List[TagsPrediction]:\n    return self._sample_handler.invoke(sample_data_list, ImageSampleBodyTransformer())  # type: ignore\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:  # type:ignore\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label)  # type:ignore\n        for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    return self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[ImageTagsSample, ImageSampleData, Image]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def create_samples(self, samples: Sequence[Union[ImageTagsSample, ImageSampleData, Image.Image]]) -&gt; List[NyckelId]:\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n    return self._sample_handler.create_samples(typed_samples, ImageSampleBodyTransformer())\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[ImageTagsSample]\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def list_samples(self) -&gt; List[ImageTagsSample]:\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {label.id: label.name for label in labels}\n\n    return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; ImageTagsSample\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; ImageTagsSample:\n    sample_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n    return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: ImageTagsSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def update_annotation(self, sample: ImageTagsSample) -&gt; None:\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/image_tags.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample","title":"nyckel.ImageTagsSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/tags/tags.py</code> <pre><code>@dataclass\nclass ImageTagsSample:\n    data: ImageSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[List[TagsAnnotation]] = None\n    prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: ImageSampleData\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[List[TagsAnnotation]] = None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageTagsSample.__init__","title":"__init__","text":"<pre><code>__init__(data: ImageSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[List[TagsAnnotation]] = None, prediction: Optional[List[ClassificationPrediction]] = None) -&gt; None\n</code></pre>"},{"location":"image_tags/#nyckel.ImageSampleData","title":"nyckel.ImageSampleData  <code>module-attribute</code>","text":"<pre><code>ImageSampleData = str\n</code></pre> <p>DataUri, Url, or local filepath.</p>"},{"location":"merge_labels/","title":"Merge two labels","text":"<p>This guide shows how to merge two labels leaving all samples associated with the second label.</p> <pre><code>from nyckel import Credentials, TextClassificationFunction, ClassificationAnnotation, TextClassificationSample\nimport time\n\nlabel_to_delete = \"\"  # This is the label name of the label to be deleted\nlabel_to_keep = \"\"  # This is the label to which we want to assign samples from the first label\n\n# Initialize your credentials and function\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\nfunc = TextClassificationFunction(\"&lt;function_id&gt;\", credentials)\n\n# Get all samples\nsamples = func.list_samples()\n\n# Filter out the sample associated with the relevant label\nsamples = [sample for sample in samples if sample.annotation]\nsamples = [sample for sample in samples if sample.annotation.label_name == label_to_delete]\n\n# Change the label of the relevant samples\nfor sample in samples:\n    sample.annotation = ClassificationAnnotation(label_name=label_to_keep)\n    func.update_annotation(sample)\n\n# Pull samples again and assert that there are no samples associated with the first label.\ntime.sleep(2)  # Give the API a second to update all the way through.\nsamples = func.list_samples()\nsamples = [sample for sample in samples if sample.annotation]\nsamples = [sample for sample in samples if sample.annotation.label_name == label_to_delete]\nassert len(samples) == 0, \"Something went wrong. There are still samples associated with the first label.\"\n\n# Delete the first label.\nlabel_id_by_name = {label.name: label.id for label in func.list_labels()}\nfunc.delete_labels([label_id_by_name[label_to_delete]])\n</code></pre>"},{"location":"multimodal_classification/","title":"Multimodal classification","text":"<p>Nyckel supports multi-modal (joint) classification of images and text data through our Tabular function types. Use <code>TabularClassificationFunction</code> for binary and multi-class classification tasks, and <code>TabularTagsFunction</code> for multi-label tagging tasks.</p>"},{"location":"multimodal_classification/#binary-and-multi-class","title":"Binary and multi-class","text":"<p>Below is an e-commerce example:</p> <pre><code>from nyckel import Credentials, TabularClassificationFunction, TabularFunctionField, TabularClassificationSample, ClassificationAnnotation\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\nfunc = TabularClassificationFunction.create(\"Product categories\", credentials)\nfunc.create_fields([\n    TabularFunctionField(name=\"Product\", type=\"Text\"),\n    TabularFunctionField(name=\"Description\", type=\"Text\"),\n    TabularFunctionField(name=\"Picture\", type=\"Image\")\n])\n\n# &lt;image-data&gt; entires can be provided as URLs, base64-encoded dataURIs, or local file paths.\nfunc.create_samples(\n    [\n        TabularClassificationSample(\n            data={\"Product\": \"Acme wrench\", \"Description\": \"Solid steel; never breaks\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=ClassificationAnnotation(label_name=\"Hardware\"),\n        ),\n        TabularClassificationSample(\n            data={\"Product\": \"ULINE Hammer\", \"Description\": \"Hammer with wood handle\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=ClassificationAnnotation(label_name=\"Hardware\"),\n        ),\n        TabularClassificationSample(\n            data={\"Product\": \"Brooklinen bedding\",\"Description\": \"Queen size bedding\",\"Picture\": \"&lt;image-data&gt;\"},\n            annotation=ClassificationAnnotation(label_name=\"Bedding\"),\n        ),\n        TabularClassificationSamplefo(\n            data={\"Product\": \"Comforter\", \"Description\": \"Nice down comforter\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=ClassificationAnnotation(label_name=\"Bedding\"),\n        ),\n    ]\n)\n</code></pre>"},{"location":"multimodal_classification/#multi-label-tagging","title":"Multi-label (tagging)","text":"<p>Nyckel also supports multi-label tagging of images and text data through our Tabular Tags function type.</p> <pre><code>from nyckel import Credentials, TabularTagsFunction, TabularFunctionField, TabularTagsSample, TagsAnnotation\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\nfunc = TabularTagsFunction.create(\"Product categories\", credentials)\nfunc.create_fields([\n    TabularFunctionField(name=\"Product\", type=\"Text\"),\n    TabularFunctionField(name=\"Description\", type=\"Text\"),\n    TabularFunctionField(name=\"Picture\", type=\"Image\")\n])\n\n# &lt;image-data&gt; entires can be provided as URLs, base64-encoded dataURIs, or local file paths.\nfunc.create_samples(\n    [\n        TabularTagsSample(\n            data={\"Product\": \"Acme wrench\", \"Description\": \"Solid steel; never breaks\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=[TagsAnnotation(label_name=\"Hardware\"), TagsAnnotation(label_name=\"US-made\")],\n        ),\n        TabularTagsSample(\n            data={\"Product\": \"ULINE Hammer\", \"Description\": \"Hammer with wood handle\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=[TagsAnnotation(label_name=\"Hardware\")],\n        ),\n        TabularTagsSample(\n            data={\"Product\": \"Brooklinen bedding\",\"Description\": \"Queen size bedding\",\"Picture\": \"&lt;image-data&gt;\"},\n            annotation=[TagsAnnotation(label_name=\"Bedding\"), TagsAnnotation(label_name=\"Organic\")],\n        ),\n        TabularTagsSample(\n            data={\"Product\": \"Comforter\", \"Description\": \"Nice down comforter\", \"Picture\": \"&lt;image-data&gt;\"},\n            annotation=[TagsAnnotation(label_name=\"Hardware\")],\n        ),\n    ]\n)\n</code></pre>"},{"location":"pretrained/","title":"Pretrained classifiers","text":"<p>Nyckel offers a variety of Pretrained Classifiers for different use cases. These classifiers are trained and maintained by Nyckel, and ready for you to use.</p>"},{"location":"pretrained/#setup","title":"Setup","text":"<ul> <li>Install the SDK: <code>pip install nyckel</code></li> <li>Get your <code>client_id</code> and <code>client_secret</code> from Nyckel</li> <li>Find the pretrained classifier <code>function_id</code> you want by visiting our Pretrained Classifiers Access Page</li> </ul>"},{"location":"pretrained/#classify-text","title":"Classify text","text":"<pre><code>import nyckel\nfunction_id = 'toxic-language-identifier'\ntext = 'Hello friend!'\ncredentials = nyckel.Credentials(client_id, client_secret)\nnyckel.invoke(function_id, text, credentials)\n{\n    'labelName': 'Not Offensive', \n    'labelId': 'label_3e46tk7jimpeozap', \n    'confidence': 0.9990668684599706\n}\n</code></pre>"},{"location":"pretrained/#classify-image","title":"Classify image","text":"<p>For image classification functions, use a <code>URL</code> or <code>base64 encoded image</code> as the input. Like so:</p> <pre><code>import nyckel\nfunction_id = 'colors-identifier'\nimage_url = \"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Altja_j%C3%B5gi_Lahemaal.jpg/320px-Altja_j%C3%B5gi_Lahemaal.jpg\"\ncredentials = nyckel.Credentials(client_id, client_secret)\nnyckel.invoke(function_id, image_url, credentials)\n{\n    'labelName': 'Green',\n    'labelId': 'label_csyoeshimzojn8xs',\n    'confidence': 0.6614829725975897\n}\n</code></pre>"},{"location":"pretrained/#reference","title":"Reference","text":""},{"location":"pretrained/#nyckel.invoke","title":"nyckel.invoke","text":"<pre><code>invoke(function_id: str, data: str, credentials: Credentials) -&gt; Dict\n</code></pre> Source code in <code>src/nyckel/functions/pretrained.py</code> <pre><code>def invoke(function_id: str, data: str, credentials: Credentials) -&gt; Dict:\n    session = credentials.get_session()\n    endpoint = f\"https://www.nyckel.com/v1/functions/{function_id}/invoke\"\n    return session.post(endpoint, json={\"data\": data}).json()\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Use the Nyckel SDK to train, deploy and invoke a text classification function.</p> <pre><code>from nyckel import Credentials, TextClassificationFunction\n\n# Get credentials from https://www.nyckel.com/console/keys\ncredentials = Credentials(client_id=..., client_secret=...)\n\n# Create a new text classification function.\nfunc = TextClassificationFunction.create(credentials=credentials, name='IsToxic')\n\n# Provide a few examples.\nfunc.add_samples([\n    ('This is a nice comment', 'not toxic'),\n    ('Hello friend', 'not toxic'),\n    ('This is a bad comment', 'toxic'),\n    ('Who is this? Go away!', 'toxic'),\n])\n\n# Nyckel trains and deploys your model in a few seconds...\n# ...and you can start classifying text right away!\n\n# Classify a new piece of text.\npredictions = func.invoke([\"This example is fantastic!\"])\n</code></pre>"},{"location":"sklearn_analytics/","title":"Integrate with sklearn","text":"<p>Using this SDK, you can easily pull down the data from Nyckel, and analyze it using sklearn, or any other library you'd like.</p> <pre><code>from nyckel import TextClassificationFunction, Credentials\n\ncredentials = Credentials(client_id = \"\", client_secret = \"\")\n\nfunction_id = \"\"\nfunc = TextClassificationFunction(function_id, credentials)\nsamples = func.list_samples()\nsamples = [s for s in samples if s.annotation] # Only keep annotated samples\nsamples = [s for s in samples if s.prediction] # Only keep predicted samples\ny_true = [s.annotation.label_name for s in samples]\ny_pred = [s.prediction.label_name for s in samples]\n\n# From here, you can use any of the sklearn metrics you'd like. For example:\n\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\ncm = ConfusionMatrixDisplay.from_predictions(y_true, y_pred)\n</code></pre> <p>For example, this is the confusion matrix for our public IsToxic function</p> <p></p>"},{"location":"tabular_classification/","title":"Tabular Classification","text":""},{"location":"tabular_classification/#nyckel.TabularClassificationFunction","title":"nyckel.TabularClassificationFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, TabularClassificationFunction, TabularFunctionField\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = TabularClassificationFunction.create(\"InterestedProspect\", credentials)\n\n# (or load existing function)\n# func = TabularClassificationFunction(\"function_id\", credentials)\n\n# Create fields\nfunc.create_fields([\n    TabularFunctionField(type=\"Text\", name=\"Name\"),\n    TabularFunctionField(type=\"Text\", name=\"Response\")\n])\n\n# Create samples\nfunc.create_samples([\n    ({\"Name\": \"Adam Adams\", \"Response\": \"Thanks for reaching out. I'd love to chat\"}, \"Interested\"),\n    ({\"Name\": \"Bo Berg\", \"Response\": \"Sure! Can you tell me a bit more?\"}, \"Interested\"),\n    ({\"Name\": \"Charles Carter\", \"Response\": \"No thanks, I don't need a Classification API\"}, \"Not Interested\"),\n    ({\"Name\": \"Devin Duncan\", \"Response\": \"Nope. Please stop bugging me.\"}, \"Not Interested\"),\n])\n\npredictions = func.invoke([{\"Name\": \"Frank Fisher\", \"Response\": \"Yea, I'd love to try the Nyckel API!\"}])\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>class TabularClassificationFunction(ClassificationFunction):\n    \"\"\"\n    Example:\n\n    ```py\n\n    from nyckel import Credentials, TabularClassificationFunction, TabularFunctionField\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = TabularClassificationFunction.create(\"InterestedProspect\", credentials)\n\n    # (or load existing function)\n    # func = TabularClassificationFunction(\"function_id\", credentials)\n\n    # Create fields\n    func.create_fields([\n        TabularFunctionField(type=\"Text\", name=\"Name\"),\n        TabularFunctionField(type=\"Text\", name=\"Response\")\n    ])\n\n    # Create samples\n    func.create_samples([\n        ({\"Name\": \"Adam Adams\", \"Response\": \"Thanks for reaching out. I'd love to chat\"}, \"Interested\"),\n        ({\"Name\": \"Bo Berg\", \"Response\": \"Sure! Can you tell me a bit more?\"}, \"Interested\"),\n        ({\"Name\": \"Charles Carter\", \"Response\": \"No thanks, I don't need a Classification API\"}, \"Not Interested\"),\n        ({\"Name\": \"Devin Duncan\", \"Response\": \"Nope. Please stop bugging me.\"}, \"Not Interested\"),\n    ])\n\n    predictions = func.invoke([{\"Name\": \"Frank Fisher\", \"Response\": \"Yea, I'd love to try the Nyckel API!\"}])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: NyckelId, credentials: Credentials) -&gt; None:\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n\n        self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._field_handler = TabularFieldHandler(function_id, credentials)\n        self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n        self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n        assert self._function_handler.get_input_modality() == \"Tabular\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def __repr__(self) -&gt; str:\n        status_string = f\"Name: {self.name}, id: {self.function_id}, url: {self._url_handler.train_page}\"\n        return status_string\n\n    @property\n    def function_id(self) -&gt; str:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"TabularClassificationFunction\":\n        return factory.ClassificationFunctionFactory.create(name, \"Tabular\", credentials)  # type: ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(  # type: ignore\n        self,\n        sample_data_list: List[TabularSampleData],\n        model_id: str = \"\",\n    ) -&gt; List[ClassificationPredictionOrError]:\n        return self._sample_handler.invoke(\n            sample_data_list, self._get_image_field_transformer(\"name\"), model_id=model_id\n        )\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        return self._label_handler.delete_labels(label_ids)\n\n    def create_fields(self, fields: List[TabularFunctionField]) -&gt; List[NyckelId]:\n        return self._field_handler.create_fields(fields)\n\n    def list_fields(self) -&gt; List[TabularFunctionField]:\n        return self._field_handler.list_fields()\n\n    def read_field(self, field_id: NyckelId) -&gt; TabularFunctionField:\n        return self._field_handler.read_field(field_id)\n\n    def delete_field(self, field_id: NyckelId) -&gt; None:\n        return self._field_handler.delete_field(field_id)\n\n    def create_samples(self, samples: Sequence[Union[TabularClassificationSample, Tuple[TabularSampleData, LabelName], TabularSampleData]]) -&gt; List[NyckelId]:  # type: ignore # noqa: E501\n        if len(samples) == 0:\n            return []\n\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._assert_fields_created(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n\n        # For large tabular functions, the POST samples API does not support field names. So we need to switch to IDs.\n        typed_samples = self._switch_field_names_to_field_ids(typed_samples)\n        return self._sample_handler.create_samples(typed_samples, self._get_image_field_transformer())\n\n    def _get_image_field_transformer(self, field_identifier: str = \"id\") -&gt; Callable:\n        fields = self.list_fields()\n        image_field_transformer = lambda x: x  # noqa: E731\n        for field in fields:\n            if field.type == \"Image\":\n                # There is only one image field (max) per function, so we can break here.\n                if field_identifier == \"id\":\n                    assert field.id is not None\n                    image_field_transformer = ImageFieldTransformer(field.id)\n                elif field_identifier == \"name\":\n                    image_field_transformer = ImageFieldTransformer(field.name)\n                break\n        return image_field_transformer\n\n    def _switch_field_names_to_field_ids(\n        self, samples: List[TabularClassificationSample]\n    ) -&gt; List[TabularClassificationSample]:\n        samples = copy.deepcopy(samples)  # Deep-copy so we don't modify the callers input.\n        fields = self.list_fields()\n        field_id_by_name = {field.name: field.id for field in fields}\n        for sample in samples:\n            field_names = list(sample.data.keys())\n            for field_name in field_names:\n                field_value = sample.data.pop(field_name)\n                sample.data[field_id_by_name[field_name]] = field_value  # type: ignore\n        return samples\n\n    def list_samples(self) -&gt; List[TabularClassificationSample]:  # type: ignore\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n        fields = self.list_fields()\n\n        label_name_by_id = {label.id: label.name for label in labels}\n        field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n        return [self._sample_from_dict(entry, label_name_by_id, field_name_by_id) for entry in samples_dict_list]  # type: ignore # noqa: E501\n\n    def read_sample(self, sample_id: NyckelId) -&gt; TabularClassificationSample:\n        sample_as_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        fields = self.list_fields()\n\n        label_name_by_id = {label.id: label.name for label in labels}\n        field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n        return self._sample_from_dict(sample_as_dict, label_name_by_id, field_name_by_id)  # type: ignore\n\n    def update_annotation(self, sample: TabularClassificationSample) -&gt; None:  # type: ignore\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n\n    def _wrangle_post_samples_input(\n        self,\n        samples: Sequence[Union[TabularClassificationSample, Tuple[TabularSampleData, LabelName], TabularSampleData]],\n    ) -&gt; List[TabularClassificationSample]:\n        typed_samples: List[TabularClassificationSample] = []\n        for sample in samples:\n            if isinstance(sample, TabularClassificationSample):\n                typed_samples.append(sample)\n            elif isinstance(sample, (list, tuple)):\n                data_dict, label_name = sample\n                typed_samples.append(\n                    TabularClassificationSample(\n                        data=data_dict, annotation=ClassificationAnnotation(label_name=label_name)\n                    )\n                )\n            elif isinstance(sample, dict):\n                typed_samples.append(TabularClassificationSample(data=sample))\n            else:\n                raise ValueError(f\"Unknown sample type: {type(sample)}\")\n        return typed_samples\n\n    def _assert_fields_created(self, samples: List[TabularClassificationSample]) -&gt; None:\n        existing_fields = self.list_fields()\n        existing_field_names = {field.name for field in existing_fields}\n        new_field_names = {field_name for sample in samples for field_name in sample.data.keys()}\n        missing_field_names = new_field_names - existing_field_names\n        assert len(missing_field_names) == 0, f\"Fields not created: {missing_field_names=}. Please create fields first.\"\n\n    def _create_labels_as_needed(self, samples: List[TabularClassificationSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names = {sample.annotation.label_name for sample in samples if sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def _sample_from_dict(\n        self, sample_dict: Dict, label_name_by_id: Dict[str, str], field_name_by_id: Dict[str, str]\n    ) -&gt; TabularClassificationSample:\n        tabular_data_body = {\n            field_name_by_id[strip_nyckel_prefix(field_id)]: field_data\n            for field_id, field_data in sample_dict[\"data\"].items()\n        }\n\n        if \"externalId\" in sample_dict:\n            external_id = sample_dict[\"externalId\"]\n        else:\n            external_id = None\n\n        if \"annotation\" in sample_dict:\n            annotation = ClassificationAnnotation(\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"annotation\"][\"labelId\"])],\n            )\n        else:\n            annotation = None\n\n        if \"prediction\" in sample_dict:\n            prediction = ClassificationPrediction(\n                confidence=sample_dict[\"prediction\"][\"confidence\"],\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"prediction\"][\"labelId\"])],\n            )\n        else:\n            prediction = None\n\n        return TabularClassificationSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=tabular_data_body,\n            external_id=external_id,\n            annotation=annotation,\n            prediction=prediction,\n        )\n\n    def _strip_label_names(self, samples: List[TabularClassificationSample]) -&gt; List[TabularClassificationSample]:\n        for sample in samples:\n            if sample.annotation:\n                sample.annotation.label_name = sample.annotation.label_name.strip()\n        return samples\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: str\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: NyckelId, credentials: Credentials) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def __init__(self, function_id: NyckelId, credentials: Credentials) -&gt; None:\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n\n    self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._field_handler = TabularFieldHandler(function_id, credentials)\n    self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n    self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n    assert self._function_handler.get_input_modality() == \"Tabular\"\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; TabularClassificationFunction\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"TabularClassificationFunction\":\n    return factory.ClassificationFunctionFactory.create(name, \"Tabular\", credentials)  # type: ignore\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[TabularSampleData], model_id: str = '') -&gt; List[ClassificationPredictionOrError]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def invoke(  # type: ignore\n    self,\n    sample_data_list: List[TabularSampleData],\n    model_id: str = \"\",\n) -&gt; List[ClassificationPredictionOrError]:\n    return self._sample_handler.invoke(\n        sample_data_list, self._get_image_field_transformer(\"name\"), model_id=model_id\n    )\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    return self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.create_fields","title":"create_fields","text":"<pre><code>create_fields(fields: List[TabularFunctionField]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def create_fields(self, fields: List[TabularFunctionField]) -&gt; List[NyckelId]:\n    return self._field_handler.create_fields(fields)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.list_fields","title":"list_fields","text":"<pre><code>list_fields() -&gt; List[TabularFunctionField]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def list_fields(self) -&gt; List[TabularFunctionField]:\n    return self._field_handler.list_fields()\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.read_field","title":"read_field","text":"<pre><code>read_field(field_id: NyckelId) -&gt; TabularFunctionField\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def read_field(self, field_id: NyckelId) -&gt; TabularFunctionField:\n    return self._field_handler.read_field(field_id)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.delete_field","title":"delete_field","text":"<pre><code>delete_field(field_id: NyckelId) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def delete_field(self, field_id: NyckelId) -&gt; None:\n    return self._field_handler.delete_field(field_id)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[TabularClassificationSample, Tuple[TabularSampleData, LabelName], TabularSampleData]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def create_samples(self, samples: Sequence[Union[TabularClassificationSample, Tuple[TabularSampleData, LabelName], TabularSampleData]]) -&gt; List[NyckelId]:  # type: ignore # noqa: E501\n    if len(samples) == 0:\n        return []\n\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._assert_fields_created(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n\n    # For large tabular functions, the POST samples API does not support field names. So we need to switch to IDs.\n    typed_samples = self._switch_field_names_to_field_ids(typed_samples)\n    return self._sample_handler.create_samples(typed_samples, self._get_image_field_transformer())\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[TabularClassificationSample]\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def list_samples(self) -&gt; List[TabularClassificationSample]:  # type: ignore\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n    fields = self.list_fields()\n\n    label_name_by_id = {label.id: label.name for label in labels}\n    field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n    return [self._sample_from_dict(entry, label_name_by_id, field_name_by_id) for entry in samples_dict_list]  # type: ignore # noqa: E501\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; TabularClassificationSample\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; TabularClassificationSample:\n    sample_as_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    fields = self.list_fields()\n\n    label_name_by_id = {label.id: label.name for label in labels}\n    field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n    return self._sample_from_dict(sample_as_dict, label_name_by_id, field_name_by_id)  # type: ignore\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: TabularClassificationSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def update_annotation(self, sample: TabularClassificationSample) -&gt; None:  # type: ignore\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/tabular_classification.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample","title":"nyckel.TabularClassificationSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass TabularClassificationSample:\n    data: TabularSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[ClassificationAnnotation] = None\n    prediction: Optional[ClassificationPrediction] = None\n    sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: TabularSampleData\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[ClassificationAnnotation] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[ClassificationPrediction] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.sample_sets","title":"sample_sets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularClassificationSample.__init__","title":"__init__","text":"<pre><code>__init__(data: TabularSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[ClassificationAnnotation] = None, prediction: Optional[ClassificationPrediction] = None, sample_sets: Optional[List[ClassificationSampleSet]] = None) -&gt; None\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularSampleData","title":"nyckel.TabularSampleData  <code>module-attribute</code>","text":"<pre><code>TabularSampleData = Dict[TabularFieldKey, TabularFieldValue]\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularFieldKey","title":"nyckel.TabularFieldKey  <code>module-attribute</code>","text":"<pre><code>TabularFieldKey = str\n</code></pre>"},{"location":"tabular_classification/#nyckel.TabularFieldValue","title":"nyckel.TabularFieldValue  <code>module-attribute</code>","text":"<pre><code>TabularFieldValue = Union[str, float]\n</code></pre>"},{"location":"tabular_tags/","title":"Tabular Tags","text":""},{"location":"tabular_tags/#nyckel.TabularTagsFunction","title":"nyckel.TabularTagsFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, TabularTagsFunction, TabularTagsSample, TagsAnnotation, TabularFunctionField\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = TabularTagsFunction.create(\"NewsTopics\", credentials)\n\n# (or load existing function)\n# func = TabularTagsFunction(\"function_id\", credentials)\n\n# Create fields\nfunc.create_fields([\n    TabularFunctionField(type=\"Text\", name=\"Title\"),\n    TabularFunctionField(type=\"Text\", name=\"Abstract\")\n])\n\n# Create samples\nfunc.create_samples([\n    TabularTagsSample(data={\"Title\": \"New restaurant in SOHO\", \"Abstract\": \"This is the best...\"}, annotation=[TagsAnnotation(\"Food\"), TagsAnnotation(\"Reviews\")]),\n    TabularTagsSample(data={\"Title\": \"Belly-up still going strong\", \"Abstract\": \"The Belly-Up tavern in Solana...\"}, annotation=[TagsAnnotation(\"Music\"), TagsAnnotation(\"Reviews\")]),\n    TabularTagsSample(data={\"Title\": \"Carbonara at its best\", \"Abstract\": \"Here is how to make the best...\"}, annotation=[TagsAnnotation(\"Food\")]),\n    TabularTagsSample(data={\"Title\": \"New album out!\", \"Abstract\": \"Taylor swift just released ...\"}, annotation=[TagsAnnotation(\"Music\")]),\n])\n\npredictions = func.invoke([{\"Title\": \"Swedish meatballs: the best recipe\", \"Abstract\": \"This age-old Swedish classic ...\"}])\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>class TabularTagsFunction(TabularTagsFunctionInterface):\n    \"\"\"\n    Example:\n\n    ```py\n\n    from nyckel import Credentials, TabularTagsFunction, TabularTagsSample, TagsAnnotation, TabularFunctionField\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = TabularTagsFunction.create(\"NewsTopics\", credentials)\n\n    # (or load existing function)\n    # func = TabularTagsFunction(\"function_id\", credentials)\n\n    # Create fields\n    func.create_fields([\n        TabularFunctionField(type=\"Text\", name=\"Title\"),\n        TabularFunctionField(type=\"Text\", name=\"Abstract\")\n    ])\n\n    # Create samples\n    func.create_samples([\n        TabularTagsSample(data={\"Title\": \"New restaurant in SOHO\", \"Abstract\": \"This is the best...\"}, annotation=[TagsAnnotation(\"Food\"), TagsAnnotation(\"Reviews\")]),\n        TabularTagsSample(data={\"Title\": \"Belly-up still going strong\", \"Abstract\": \"The Belly-Up tavern in Solana...\"}, annotation=[TagsAnnotation(\"Music\"), TagsAnnotation(\"Reviews\")]),\n        TabularTagsSample(data={\"Title\": \"Carbonara at its best\", \"Abstract\": \"Here is how to make the best...\"}, annotation=[TagsAnnotation(\"Food\")]),\n        TabularTagsSample(data={\"Title\": \"New album out!\", \"Abstract\": \"Taylor swift just released ...\"}, annotation=[TagsAnnotation(\"Music\")]),\n    ])\n\n    predictions = func.invoke([{\"Title\": \"Swedish meatballs: the best recipe\", \"Abstract\": \"This age-old Swedish classic ...\"}])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: NyckelId, credentials: Credentials):\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n\n        self._function_handler = TagsFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n        self._sample_handler = TagsSampleHandler(function_id, credentials)\n        self._field_handler = TabularFieldHandler(function_id, credentials)\n\n        assert self._function_handler.get_input_modality() == \"Tabular\"\n\n    @property\n    def function_id(self) -&gt; NyckelId:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"TabularTagsFunction\":\n        return tags_function_factory.TagsFunctionFactory().create(name, \"Tabular\", credentials)  # type:ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(self, sample_data_list: List[TabularSampleData]) -&gt; List[TagsPrediction]:\n        return self._sample_handler.invoke(sample_data_list, self._get_image_field_transformer(\"name\"))\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        self._label_handler.delete_labels(label_ids)\n\n    def create_fields(self, fields: List[TabularFunctionField]) -&gt; List[NyckelId]:\n        return self._field_handler.create_fields(fields)\n\n    def list_fields(self) -&gt; List[TabularFunctionField]:\n        return self._field_handler.list_fields()\n\n    def read_field(self, field_id: NyckelId) -&gt; TabularFunctionField:\n        return self._field_handler.read_field(field_id)\n\n    def delete_field(self, field_id: NyckelId) -&gt; None:\n        return self._field_handler.delete_field(field_id)\n\n    def create_samples(self, samples: Sequence[Union[TabularTagsSample, TabularSampleData]]) -&gt; List[NyckelId]:\n        if len(samples) == 0:\n            return []\n\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._assert_fields_created(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n\n        # For large tabular functions, the POST samples API does not support field names. So we need to switch to IDs.\n        typed_samples = self._switch_field_names_to_field_ids(typed_samples)\n        return self._sample_handler.create_samples(typed_samples, self._get_image_field_transformer())\n\n    def _wrangle_post_samples_input(\n        self, samples: Sequence[Union[TabularTagsSample, TabularSampleData]]\n    ) -&gt; List[TabularTagsSample]:\n        typed_samples: List[TabularTagsSample] = []\n        for sample in samples:\n            if isinstance(sample, TabularTagsSample):\n                typed_samples.append(sample)\n            elif isinstance(sample, dict):\n                typed_samples.append(TabularTagsSample(data=sample))\n            else:\n                raise ValueError(f\"Sample {sample} has invalid type: {type(sample)}\")\n        return typed_samples\n\n    def _strip_label_names(self, samples: List[TabularTagsSample]) -&gt; List[TabularTagsSample]:\n        for sample in samples:\n            if sample.annotation:\n                for entry in sample.annotation:\n                    entry.label_name = entry.label_name.strip()\n        return samples\n\n    def _assert_fields_created(self, samples: List[TabularTagsSample]) -&gt; None:\n        existing_fields = self.list_fields()\n        existing_field_names = {field.name for field in existing_fields}\n        new_field_names = {field_name for sample in samples for field_name in sample.data.keys()}\n        missing_field_names = new_field_names - existing_field_names\n        assert len(missing_field_names) == 0, f\"Fields not created: {missing_field_names=}. Please create fields first.\"\n\n    def _create_labels_as_needed(self, samples: List[TabularTagsSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names: set = set()\n        for sample in samples:\n            if sample.annotation:\n                new_label_names |= {annotation.label_name for annotation in sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def _get_image_field_transformer(self, field_identifier: str = \"id\") -&gt; Callable:\n        fields = self.list_fields()\n        image_field_transformer = lambda x: x  # noqa: E731\n        for field in fields:\n            if field.type == \"Image\":\n                # There is only one image field (max) per function, so we can break here.\n                if field_identifier == \"id\":\n                    assert field.id is not None\n                    image_field_transformer = ImageFieldTransformer(field.id)\n                elif field_identifier == \"name\":\n                    image_field_transformer = ImageFieldTransformer(field.name)\n                break\n        return image_field_transformer\n\n    def _switch_field_names_to_field_ids(self, samples: List[TabularTagsSample]) -&gt; List[TabularTagsSample]:\n        samples = copy.deepcopy(samples)  # Deep-copy so we don't modify the callers input.\n        fields = self.list_fields()\n        field_id_by_name = {field.name: field.id for field in fields}\n        for sample in samples:\n            field_names = list(sample.data.keys())\n            for field_name in field_names:\n                field_value = sample.data.pop(field_name)\n                sample.data[field_id_by_name[field_name]] = field_value  # type: ignore\n        return samples\n\n    def list_samples(self) -&gt; List[TabularTagsSample]:\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n        fields = self.list_fields()\n\n        label_name_by_id = {label.id: label.name for label in labels}\n        field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n        return [self._sample_from_dict(entry, label_name_by_id, field_name_by_id) for entry in samples_dict_list]  # type: ignore # noqa: E501\n\n    def _sample_from_dict(\n        self, sample_dict: Dict, label_name_by_id: Dict[str, str], field_name_by_id: Dict[str, str]\n    ) -&gt; TabularTagsSample:\n\n        tabular_data_body = {\n            field_name_by_id[strip_nyckel_prefix(field_id)]: field_data\n            for field_id, field_data in sample_dict[\"data\"].items()\n        }\n\n        if \"annotation\" in sample_dict:\n            annotation = [\n                TagsAnnotation(\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                    present=entry[\"present\"],\n                )\n                for entry in sample_dict[\"annotation\"]\n            ]\n        else:\n            annotation = None\n\n        if \"prediction\" in sample_dict:\n            # TODO: Note that we filter out predictsion that are not in the label list.\n            # This is a temporary fix since these should not be there in the first place.\n\n            prediction = [\n                ClassificationPrediction(\n                    confidence=entry[\"confidence\"],\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                )\n                for entry in sample_dict[\"prediction\"]\n                if strip_nyckel_prefix(entry[\"labelId\"]) in label_name_by_id\n            ]\n        else:\n            prediction = None\n\n        return TabularTagsSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=tabular_data_body,\n            external_id=sample_dict[\"externalId\"] if \"externalId\" in sample_dict else None,\n            annotation=annotation,\n            prediction=prediction,\n        )\n\n    def read_sample(self, sample_id: NyckelId) -&gt; TabularTagsSample:\n        sample_as_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        fields = self.list_fields()\n\n        label_name_by_id = {label.id: label.name for label in labels}\n        field_name_by_id = {field.id: field.name for field in fields}\n\n        return self._sample_from_dict(sample_as_dict, label_name_by_id, field_name_by_id)\n\n    def update_annotation(self, sample: TabularTagsSample) -&gt; None:\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: NyckelId\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: NyckelId, credentials: Credentials)\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def __init__(self, function_id: NyckelId, credentials: Credentials):\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n\n    self._function_handler = TagsFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n    self._sample_handler = TagsSampleHandler(function_id, credentials)\n    self._field_handler = TabularFieldHandler(function_id, credentials)\n\n    assert self._function_handler.get_input_modality() == \"Tabular\"\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; TabularTagsFunction\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"TabularTagsFunction\":\n    return tags_function_factory.TagsFunctionFactory().create(name, \"Tabular\", credentials)  # type:ignore\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[TabularSampleData]) -&gt; List[TagsPrediction]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def invoke(self, sample_data_list: List[TabularSampleData]) -&gt; List[TagsPrediction]:\n    return self._sample_handler.invoke(sample_data_list, self._get_image_field_transformer(\"name\"))\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.create_fields","title":"create_fields","text":"<pre><code>create_fields(fields: List[TabularFunctionField]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def create_fields(self, fields: List[TabularFunctionField]) -&gt; List[NyckelId]:\n    return self._field_handler.create_fields(fields)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.list_fields","title":"list_fields","text":"<pre><code>list_fields() -&gt; List[TabularFunctionField]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def list_fields(self) -&gt; List[TabularFunctionField]:\n    return self._field_handler.list_fields()\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.read_field","title":"read_field","text":"<pre><code>read_field(field_id: NyckelId) -&gt; TabularFunctionField\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def read_field(self, field_id: NyckelId) -&gt; TabularFunctionField:\n    return self._field_handler.read_field(field_id)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.delete_field","title":"delete_field","text":"<pre><code>delete_field(field_id: NyckelId) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def delete_field(self, field_id: NyckelId) -&gt; None:\n    return self._field_handler.delete_field(field_id)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[TabularTagsSample, TabularSampleData]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def create_samples(self, samples: Sequence[Union[TabularTagsSample, TabularSampleData]]) -&gt; List[NyckelId]:\n    if len(samples) == 0:\n        return []\n\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._assert_fields_created(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n\n    # For large tabular functions, the POST samples API does not support field names. So we need to switch to IDs.\n    typed_samples = self._switch_field_names_to_field_ids(typed_samples)\n    return self._sample_handler.create_samples(typed_samples, self._get_image_field_transformer())\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[TabularTagsSample]\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def list_samples(self) -&gt; List[TabularTagsSample]:\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n    fields = self.list_fields()\n\n    label_name_by_id = {label.id: label.name for label in labels}\n    field_name_by_id = {field.id: field.name for field in fields}  # type: ignore\n\n    return [self._sample_from_dict(entry, label_name_by_id, field_name_by_id) for entry in samples_dict_list]  # type: ignore # noqa: E501\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; TabularTagsSample\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; TabularTagsSample:\n    sample_as_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    fields = self.list_fields()\n\n    label_name_by_id = {label.id: label.name for label in labels}\n    field_name_by_id = {field.id: field.name for field in fields}\n\n    return self._sample_from_dict(sample_as_dict, label_name_by_id, field_name_by_id)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: TabularTagsSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def update_annotation(self, sample: TabularTagsSample) -&gt; None:\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/tabular_tags.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample","title":"nyckel.TabularTagsSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/tags/tags.py</code> <pre><code>@dataclass\nclass TabularTagsSample:\n    data: TabularSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[List[TagsAnnotation]] = None\n    prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: TabularSampleData\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[List[TagsAnnotation]] = None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularTagsSample.__init__","title":"__init__","text":"<pre><code>__init__(data: TabularSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[List[TagsAnnotation]] = None, prediction: Optional[List[ClassificationPrediction]] = None) -&gt; None\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularSampleData","title":"nyckel.TabularSampleData  <code>module-attribute</code>","text":"<pre><code>TabularSampleData = Dict[TabularFieldKey, TabularFieldValue]\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularFieldKey","title":"nyckel.TabularFieldKey  <code>module-attribute</code>","text":"<pre><code>TabularFieldKey = str\n</code></pre>"},{"location":"tabular_tags/#nyckel.TabularFieldValue","title":"nyckel.TabularFieldValue  <code>module-attribute</code>","text":"<pre><code>TabularFieldValue = Union[str, float]\n</code></pre>"},{"location":"text_classification/","title":"Text Classification","text":""},{"location":"text_classification/#nyckel.TextClassificationFunction","title":"nyckel.TextClassificationFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, TextClassificationFunction\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = TextClassificationFunction.create(\"IsToxic\", credentials)\n\n# (or load existing function)\n# func = TextClassificationFunction(\"function_id\", credentials)\n\n# Create samples\nfunc.create_samples([\n    (\"This is a nice comment\", \"Not toxic\"),\n    (\"Hello friend\", \"Not toxic\"),\n    (\"I hate people like you\", \"Toxic\"),\n    (\"Who is this? Go away!\", \"Toxic\"),\n])\n\npredictions = func.invoke([\"This example is fantastic!\"])\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>class TextClassificationFunction(ClassificationFunction):\n    \"\"\"\n    Example:\n\n    ```py\n\n    from nyckel import Credentials, TextClassificationFunction\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = TextClassificationFunction.create(\"IsToxic\", credentials)\n\n    # (or load existing function)\n    # func = TextClassificationFunction(\"function_id\", credentials)\n\n    # Create samples\n    func.create_samples([\n        (\"This is a nice comment\", \"Not toxic\"),\n        (\"Hello friend\", \"Not toxic\"),\n        (\"I hate people like you\", \"Toxic\"),\n        (\"Who is this? Go away!\", \"Toxic\"),\n    ])\n\n    predictions = func.invoke([\"This example is fantastic!\"])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: NyckelId, credentials: Credentials):\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n\n        self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n        self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n\n        assert self._function_handler.get_input_modality() == \"Text\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def __repr__(self) -&gt; str:\n        status_string = f\"Name: {self.name}, id: {self.function_id}, url: {self._url_handler.train_page}\"\n        return status_string\n\n    @property\n    def function_id(self) -&gt; str:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"TextClassificationFunction\":\n        return factory.ClassificationFunctionFactory.create(name, \"Text\", credentials)  # type:ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(\n        self,\n        sample_data_list: List[TextSampleData],\n        model_id: str = \"\",\n    ) -&gt; List[ClassificationPredictionOrError]:\n        return self._sample_handler.invoke(sample_data_list, lambda x: x, model_id=model_id)\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        return self._label_handler.delete_labels(label_ids)\n\n    def create_samples(\n        self, samples: Sequence[Union[TextClassificationSample, Tuple[TextSampleData, LabelName], TextSampleData]]  # type: ignore  # noqa: E501\n    ) -&gt; List[NyckelId]:\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n\n        return self._sample_handler.create_samples(typed_samples, lambda x: x)\n\n    def list_samples(self) -&gt; List[TextClassificationSample]:  # type: ignore\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n\n        label_name_by_id = {label.id: label.name for label in labels}\n\n        return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n\n    def read_sample(self, sample_id: NyckelId) -&gt; TextClassificationSample:\n        sample_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n        return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n\n    def update_annotation(self, sample: TextClassificationSample) -&gt; None:  # type: ignore\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n\n    def _sample_from_dict(self, sample_dict: Dict, label_name_by_id: Dict[NyckelId, str]) -&gt; TextClassificationSample:\n        if \"annotation\" in sample_dict:\n            annotation = ClassificationAnnotation(\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"annotation\"][\"labelId\"])],\n            )\n        else:\n            annotation = None\n        if \"prediction\" in sample_dict:\n            prediction = ClassificationPrediction(\n                confidence=sample_dict[\"prediction\"][\"confidence\"],\n                label_name=label_name_by_id[strip_nyckel_prefix(sample_dict[\"prediction\"][\"labelId\"])],\n            )\n        else:\n            prediction = None\n        return TextClassificationSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=sample_dict[\"data\"],\n            external_id=sample_dict[\"externalId\"] if \"externalId\" in sample_dict else None,\n            annotation=annotation,\n            prediction=prediction,\n        )\n\n    def _wrangle_post_samples_input(\n        self, samples: Sequence[Union[TextClassificationSample, Tuple[TextSampleData, LabelName], TextSampleData]]\n    ) -&gt; List[TextClassificationSample]:\n        typed_samples: List[TextClassificationSample] = []\n        for sample in samples:\n            if isinstance(sample, str):\n                typed_samples.append(TextClassificationSample(data=sample))\n            elif isinstance(sample, (list, tuple)):\n                typed_samples.append(\n                    TextClassificationSample(data=sample[0], annotation=ClassificationAnnotation(label_name=sample[1]))\n                )\n            elif isinstance(sample, TextClassificationSample):\n                typed_samples.append(sample)\n            else:\n                raise ValueError(f\"Unknown sample type: {type(sample)}\")\n        return typed_samples\n\n    def _create_labels_as_needed(self, samples: List[TextClassificationSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names = {sample.annotation.label_name for sample in samples if sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def _strip_label_names(self, samples: List[TextClassificationSample]) -&gt; List[TextClassificationSample]:\n        for sample in samples:\n            if sample.annotation:\n                sample.annotation.label_name = sample.annotation.label_name.strip()\n        return samples\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: str\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: NyckelId, credentials: Credentials)\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def __init__(self, function_id: NyckelId, credentials: Credentials):\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n\n    self._function_handler = ClassificationFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._url_handler = ClassificationFunctionURLHandler(function_id, credentials.server_url)\n    self._sample_handler = ClassificationSampleHandler(function_id, credentials)\n\n    assert self._function_handler.get_input_modality() == \"Text\"\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; TextClassificationFunction\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"TextClassificationFunction\":\n    return factory.ClassificationFunctionFactory.create(name, \"Text\", credentials)  # type:ignore\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[TextSampleData], model_id: str = '') -&gt; List[ClassificationPredictionOrError]\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def invoke(\n    self,\n    sample_data_list: List[TextSampleData],\n    model_id: str = \"\",\n) -&gt; List[ClassificationPredictionOrError]:\n    return self._sample_handler.invoke(sample_data_list, lambda x: x, model_id=model_id)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label) for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    return self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[TextClassificationSample, Tuple[TextSampleData, LabelName], TextSampleData]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def create_samples(\n    self, samples: Sequence[Union[TextClassificationSample, Tuple[TextSampleData, LabelName], TextSampleData]]  # type: ignore  # noqa: E501\n) -&gt; List[NyckelId]:\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n\n    return self._sample_handler.create_samples(typed_samples, lambda x: x)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[TextClassificationSample]\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def list_samples(self) -&gt; List[TextClassificationSample]:  # type: ignore\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n\n    label_name_by_id = {label.id: label.name for label in labels}\n\n    return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; TextClassificationSample\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; TextClassificationSample:\n    sample_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n    return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: TextClassificationSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def update_annotation(self, sample: TextClassificationSample) -&gt; None:  # type: ignore\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/classification/text_classification.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample","title":"nyckel.TextClassificationSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/classification/classification.py</code> <pre><code>@dataclass\nclass TextClassificationSample:\n    data: TextSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[ClassificationAnnotation] = None\n    prediction: Optional[ClassificationPrediction] = None\n    sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: TextSampleData\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[ClassificationAnnotation] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[ClassificationPrediction] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.sample_sets","title":"sample_sets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sample_sets: Optional[List[ClassificationSampleSet]] = None\n</code></pre>"},{"location":"text_classification/#nyckel.TextClassificationSample.__init__","title":"__init__","text":"<pre><code>__init__(data: TextSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[ClassificationAnnotation] = None, prediction: Optional[ClassificationPrediction] = None, sample_sets: Optional[List[ClassificationSampleSet]] = None) -&gt; None\n</code></pre>"},{"location":"text_classification/#nyckel.TextSampleData","title":"nyckel.TextSampleData  <code>module-attribute</code>","text":"<pre><code>TextSampleData = str\n</code></pre>"},{"location":"text_tags/","title":"Text Tags","text":""},{"location":"text_tags/#nyckel.TextTagsFunction","title":"nyckel.TextTagsFunction","text":"<p>Example:</p> <pre><code>from nyckel import Credentials, TextTagsFunction, TextTagsSample, TagsAnnotation\n\ncredentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n# Create new function\nfunc = TextTagsFunction.create(\"NewsTopics\", credentials)\n\n# (or load existing function)\n# func = TextTagsFunction(\"function_id\", credentials)\n\n# Create samples\nfunc.create_samples([\n    TextTagsSample(data=\"This is the best restaurant in NYC.\", annotation=[TagsAnnotation(\"Food\"), TagsAnnotation(\"Reviews\")]),\n    TextTagsSample(data=\"The Belly-Up tavern in Solana Beach...\", annotation=[TagsAnnotation(\"Music\"), TagsAnnotation(\"Reviews\")]),\n    TextTagsSample(data=\"Here is how to make the best Pasta Carbonara.\", annotation=[TagsAnnotation(\"Food\")]),\n    TextTagsSample(data=\"Taylor swift just released a new album, again.\", annotation=[TagsAnnotation(\"Music\")]),\n])\n\npredictions = func.invoke([\"Swedish meatballs: the best recipes\"])\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>class TextTagsFunction:\n    \"\"\"\n    Example:\n\n    ```py\n\n    from nyckel import Credentials, TextTagsFunction, TextTagsSample, TagsAnnotation\n\n    credentials = Credentials(client_id=\"...\", client_secret=\"...\")\n\n    # Create new function\n    func = TextTagsFunction.create(\"NewsTopics\", credentials)\n\n    # (or load existing function)\n    # func = TextTagsFunction(\"function_id\", credentials)\n\n    # Create samples\n    func.create_samples([\n        TextTagsSample(data=\"This is the best restaurant in NYC.\", annotation=[TagsAnnotation(\"Food\"), TagsAnnotation(\"Reviews\")]),\n        TextTagsSample(data=\"The Belly-Up tavern in Solana Beach...\", annotation=[TagsAnnotation(\"Music\"), TagsAnnotation(\"Reviews\")]),\n        TextTagsSample(data=\"Here is how to make the best Pasta Carbonara.\", annotation=[TagsAnnotation(\"Food\")]),\n        TextTagsSample(data=\"Taylor swift just released a new album, again.\", annotation=[TagsAnnotation(\"Music\")]),\n    ])\n\n    predictions = func.invoke([\"Swedish meatballs: the best recipes\"])\n    ```\n    \"\"\"\n\n    def __init__(self, function_id: NyckelId, credentials: Credentials):\n        function_id = strip_nyckel_prefix(function_id)\n        self._function_id = function_id\n\n        self._function_handler = TagsFunctionHandler(function_id, credentials)\n        self._label_handler = ClassificationLabelHandler(function_id, credentials)\n        self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n        self._sample_handler = TagsSampleHandler(function_id, credentials)\n\n        assert self._function_handler.get_input_modality() == \"Text\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def __repr__(self) -&gt; str:\n        status_string = f\"Name: {self.name}, id: {self.function_id}, url: {self._url_handler.train_page}\"\n        return status_string\n\n    @property\n    def function_id(self) -&gt; str:\n        return self._function_id\n\n    @property\n    def sample_count(self) -&gt; int:\n        return self._function_handler.sample_count\n\n    @property\n    def label_count(self) -&gt; int:\n        return self._function_handler.label_count\n\n    @property\n    def name(self) -&gt; str:\n        return self._function_handler.get_name()\n\n    @classmethod\n    def create(cls, name: str, credentials: Credentials) -&gt; \"TextTagsFunction\":\n        return tags_function_factory.TagsFunctionFactory().create(name, \"Text\", credentials)  # type:ignore\n\n    def delete(self) -&gt; None:\n        self._function_handler.delete()\n\n    def invoke(self, sample_data_list: List[str]) -&gt; List[TagsPrediction]:\n        \"\"\"Invokes the trained function. Raises ValueError if function is not trained\"\"\"\n        return self._sample_handler.invoke(sample_data_list, lambda x: x)  # type: ignore\n\n    def has_trained_model(self) -&gt; bool:\n        return self._function_handler.is_trained\n\n    def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:  # type:ignore\n        typed_labels = [\n            label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label)  # type:ignore\n            for label in labels\n        ]\n        return self._label_handler.create_labels(typed_labels)\n\n    def list_labels(self) -&gt; List[ClassificationLabel]:\n        return self._label_handler.list_labels(self.label_count)\n\n    def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n        return self._label_handler.read_label(label_id)\n\n    def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n        return self._label_handler.update_label(label)\n\n    def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n        return self._label_handler.delete_labels(label_ids)\n\n    def create_samples(self, samples: Sequence[Union[TextTagsSample, TextSampleData]]) -&gt; List[NyckelId]:  # type:ignore\n        typed_samples = self._wrangle_post_samples_input(samples)\n        typed_samples = self._strip_label_names(typed_samples)\n        self._create_labels_as_needed(typed_samples)\n\n        return self._sample_handler.create_samples(typed_samples, lambda x: x)\n\n    def _wrangle_post_samples_input(\n        self, samples: Sequence[Union[TextTagsSample, TextSampleData]]\n    ) -&gt; List[TextTagsSample]:\n        typed_samples: List[TextTagsSample] = []\n        for sample in samples:\n            if isinstance(sample, str):\n                typed_samples.append(TextTagsSample(data=sample))\n            elif isinstance(sample, TextTagsSample):\n                typed_samples.append(sample)\n            else:\n                raise ValueError(f\"Unknown sample type: {type(sample)}\")\n        return typed_samples\n\n    def _strip_label_names(self, samples: List[TextTagsSample]) -&gt; List[TextTagsSample]:\n        for sample in samples:\n            if sample.annotation:\n                for entry in sample.annotation:\n                    entry.label_name = entry.label_name.strip()\n        return samples\n\n    def _create_labels_as_needed(self, samples: List[TextTagsSample]) -&gt; None:\n        existing_labels = self._label_handler.list_labels(None)\n        existing_label_names = {label.name for label in existing_labels}\n        new_label_names: set = set()\n        for sample in samples:\n            if sample.annotation:\n                new_label_names |= {annotation.label_name for annotation in sample.annotation}\n        missing_label_names = new_label_names - existing_label_names\n        missing_labels = [ClassificationLabel(name=label_name) for label_name in missing_label_names]\n        if len(missing_labels) &gt; 0:\n            self._label_handler.create_labels(missing_labels)\n\n    def list_samples(self) -&gt; List[TextTagsSample]:\n        samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {label.id: label.name for label in labels}\n\n        return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n\n    def _sample_from_dict(self, sample_dict: Dict, label_name_by_id: Dict[NyckelId, str]) -&gt; TextTagsSample:\n        if \"annotation\" in sample_dict:\n            annotation = [\n                TagsAnnotation(\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                    present=entry[\"present\"],\n                )\n                for entry in sample_dict[\"annotation\"]\n            ]\n        else:\n            annotation = None\n\n        if \"prediction\" in sample_dict:\n            prediction = [\n                ClassificationPrediction(\n                    confidence=entry[\"confidence\"],\n                    label_name=label_name_by_id[strip_nyckel_prefix(entry[\"labelId\"])],\n                )\n                for entry in sample_dict[\"prediction\"]\n            ]\n        else:\n            prediction = None\n\n        return TextTagsSample(\n            id=strip_nyckel_prefix(sample_dict[\"id\"]),\n            data=sample_dict[\"data\"],\n            external_id=sample_dict[\"externalId\"] if \"externalId\" in sample_dict else None,\n            annotation=annotation,\n            prediction=prediction,\n        )\n\n    def read_sample(self, sample_id: NyckelId) -&gt; TextTagsSample:\n        sample_dict = self._sample_handler.read_sample(sample_id)\n\n        labels = self._label_handler.list_labels(None)\n        label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n        return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n\n    def update_annotation(self, sample: TextTagsSample) -&gt; None:\n        self._sample_handler.update_annotation(sample)\n\n    def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n        self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.function_id","title":"function_id  <code>property</code>","text":"<pre><code>function_id: str\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.sample_count","title":"sample_count  <code>property</code>","text":"<pre><code>sample_count: int\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.label_count","title":"label_count  <code>property</code>","text":"<pre><code>label_count: int\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.__init__","title":"__init__","text":"<pre><code>__init__(function_id: NyckelId, credentials: Credentials)\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def __init__(self, function_id: NyckelId, credentials: Credentials):\n    function_id = strip_nyckel_prefix(function_id)\n    self._function_id = function_id\n\n    self._function_handler = TagsFunctionHandler(function_id, credentials)\n    self._label_handler = ClassificationLabelHandler(function_id, credentials)\n    self._url_handler = TagsFunctionURLHandler(function_id, credentials.server_url)\n    self._sample_handler = TagsSampleHandler(function_id, credentials)\n\n    assert self._function_handler.get_input_modality() == \"Text\"\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(name: str, credentials: Credentials) -&gt; TextTagsFunction\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>@classmethod\ndef create(cls, name: str, credentials: Credentials) -&gt; \"TextTagsFunction\":\n    return tags_function_factory.TagsFunctionFactory().create(name, \"Text\", credentials)  # type:ignore\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def delete(self) -&gt; None:\n    self._function_handler.delete()\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.invoke","title":"invoke","text":"<pre><code>invoke(sample_data_list: List[str]) -&gt; List[TagsPrediction]\n</code></pre> <p>Invokes the trained function. Raises ValueError if function is not trained</p> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def invoke(self, sample_data_list: List[str]) -&gt; List[TagsPrediction]:\n    \"\"\"Invokes the trained function. Raises ValueError if function is not trained\"\"\"\n    return self._sample_handler.invoke(sample_data_list, lambda x: x)  # type: ignore\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.has_trained_model","title":"has_trained_model","text":"<pre><code>has_trained_model() -&gt; bool\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def has_trained_model(self) -&gt; bool:\n    return self._function_handler.is_trained\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.create_labels","title":"create_labels","text":"<pre><code>create_labels(labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def create_labels(self, labels: Sequence[Union[ClassificationLabel, str]]) -&gt; List[NyckelId]:  # type:ignore\n    typed_labels = [\n        label if isinstance(label, ClassificationLabel) else ClassificationLabel(name=label)  # type:ignore\n        for label in labels\n    ]\n    return self._label_handler.create_labels(typed_labels)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; List[ClassificationLabel]\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def list_labels(self) -&gt; List[ClassificationLabel]:\n    return self._label_handler.list_labels(self.label_count)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.read_label","title":"read_label","text":"<pre><code>read_label(label_id: NyckelId) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def read_label(self, label_id: NyckelId) -&gt; ClassificationLabel:\n    return self._label_handler.read_label(label_id)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.update_label","title":"update_label","text":"<pre><code>update_label(label: ClassificationLabel) -&gt; ClassificationLabel\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def update_label(self, label: ClassificationLabel) -&gt; ClassificationLabel:\n    return self._label_handler.update_label(label)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(label_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def delete_labels(self, label_ids: List[NyckelId]) -&gt; None:\n    return self._label_handler.delete_labels(label_ids)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.create_samples","title":"create_samples","text":"<pre><code>create_samples(samples: Sequence[Union[TextTagsSample, TextSampleData]]) -&gt; List[NyckelId]\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def create_samples(self, samples: Sequence[Union[TextTagsSample, TextSampleData]]) -&gt; List[NyckelId]:  # type:ignore\n    typed_samples = self._wrangle_post_samples_input(samples)\n    typed_samples = self._strip_label_names(typed_samples)\n    self._create_labels_as_needed(typed_samples)\n\n    return self._sample_handler.create_samples(typed_samples, lambda x: x)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.list_samples","title":"list_samples","text":"<pre><code>list_samples() -&gt; List[TextTagsSample]\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def list_samples(self) -&gt; List[TextTagsSample]:\n    samples_dict_list = self._sample_handler.list_samples(self.sample_count)\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {label.id: label.name for label in labels}\n\n    return [self._sample_from_dict(entry, label_name_by_id) for entry in samples_dict_list]  # type: ignore\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.read_sample","title":"read_sample","text":"<pre><code>read_sample(sample_id: NyckelId) -&gt; TextTagsSample\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def read_sample(self, sample_id: NyckelId) -&gt; TextTagsSample:\n    sample_dict = self._sample_handler.read_sample(sample_id)\n\n    labels = self._label_handler.list_labels(None)\n    label_name_by_id = {strip_nyckel_prefix(label.id): label.name for label in labels}  # type: ignore\n\n    return self._sample_from_dict(sample_dict, label_name_by_id)  # type: ignore\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.update_annotation","title":"update_annotation","text":"<pre><code>update_annotation(sample: TextTagsSample) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def update_annotation(self, sample: TextTagsSample) -&gt; None:\n    self._sample_handler.update_annotation(sample)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsFunction.delete_samples","title":"delete_samples","text":"<pre><code>delete_samples(sample_ids: List[NyckelId]) -&gt; None\n</code></pre> Source code in <code>src/nyckel/functions/tags/text_tags.py</code> <pre><code>def delete_samples(self, sample_ids: List[NyckelId]) -&gt; None:\n    self._sample_handler.delete_samples(sample_ids)\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample","title":"nyckel.TextTagsSample  <code>dataclass</code>","text":"Source code in <code>src/nyckel/functions/tags/tags.py</code> <pre><code>@dataclass\nclass TextTagsSample:\n    data: TextSampleData\n    id: Optional[NyckelId] = None\n    external_id: Optional[str] = None\n    annotation: Optional[List[TagsAnnotation]] = None\n    prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: TextSampleData\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[NyckelId] = None\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.external_id","title":"external_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_id: Optional[str] = None\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.annotation","title":"annotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotation: Optional[List[TagsAnnotation]] = None\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.prediction","title":"prediction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prediction: Optional[List[ClassificationPrediction]] = None\n</code></pre>"},{"location":"text_tags/#nyckel.TextTagsSample.__init__","title":"__init__","text":"<pre><code>__init__(data: TextSampleData, id: Optional[NyckelId] = None, external_id: Optional[str] = None, annotation: Optional[List[TagsAnnotation]] = None, prediction: Optional[List[ClassificationPrediction]] = None) -&gt; None\n</code></pre>"},{"location":"text_tags/#nyckel.TextSampleData","title":"nyckel.TextSampleData  <code>module-attribute</code>","text":"<pre><code>TextSampleData = str\n</code></pre>"}]}